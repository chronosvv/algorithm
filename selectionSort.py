# 数组和链表
    # 链表的优势在插入元素方面

    # 链表存在类似的问题。在需要读取链表的最后一个元素时,你不能直接读取,因为你不知道它所处的地址,
    # 必须先访问元素#1,从中获取元素#2的地址,再访问元素#2并从中获取元素#3 的地址,
    # 以此类推,直到访问最后一个元素。如果你需要跳跃,链表的效率真的很低。

    # 数组与此不同:你知道其中每个元素的地址。

#         数组  链表
# 读取     O(1) O(n)
# 插入     O(n) O(1)

# 练习
# 2.1 假设你要编写一个记账的应用程序。
#     1.买杂货
#     2.看电影
#     3.吃东西
# 你每天都将所有的支出记录下来,并在月底统计支出,算算当月花了多少钱。因此,
# 你执行的插入操作很多,但读取操作很少。该使用数组还是链表呢?


# 删除

# 删除元素,链表也是更好的选择,因为只需修改前一个元素指向的地址即可。而
# 使用数组时,删除元素后,必须将后面的元素都向前移。

#         数组  链表
# 读取     O(1) O(n)
# 插入     O(n) O(1)
# 删除     O(n) O(1)

# 需要指出的是,仅当能够立即访问要删除的元素时,删除操作的运行时间才为O(1)。通常我
# 们都记录了链表的第一个元素和最后一个元素,因此删除这些元素时运行时间为O(1)。

# 练习
# 2.2 假设你要为饭店创建一个接受顾客点菜单的应用程序。这个应用程序存储一系列点菜
# 单。服务员添加点菜单,而厨师取出点菜单并制作菜肴。这是一个点菜单队列:服务
# 员在队尾添加点菜单,厨师取出队列开头的点菜单并制作菜肴。
# 你使用数组还是链表来实现这个队列呢?(提示:链表擅长插入和删除,而数组擅长
# 随机访问。在这个应用程序中,你要执行的是哪些操作呢?)

# 2.3 我们来做一个思考实验。假设Facebook记录一系列用户名,每当有用户试图登录
# Facebook时,都查找其用户名,如果找到就允许用户登录。由于经常有用户登录
# Facebook,因此需要执行大量的用户名查找操作。假设Facebook使/用二分查找算法,
# 而这种算法要求能够随机访问——立即获取中间的用户名。考虑到这一点,应使用数
# 组还是链表来存储用户名呢?

# 2.4 经常有用户在Facebook注册。假设你已决定使用数组来存储用户名,在插入方面数组
# 有何缺点呢?具体地说,在数组中添加新用户将出现什么情况?

# 2.5 实际上,Facebook存储用户信息时使用的既不是数组也不是链表。假设Facebook使用
# 的是一种混合数据:链表数组。这个数组包含26个元素,每个元素都指向一个链表。
# 例如,该数组的第一个元素指向的链表包含所有以A打头的用户名,第二个元素指向的
# 链表包含所有以B打头的用户名,以此类推。

# 假设Adit B在Facebook注册,而你需要将其加入前述数据结构中。因此,你访问数组的
# 第一个元素,再访问该元素指向的链表,并将Adit B添加到这个链表末尾。现在假设你2.3 选择排序
# 要查找Zakhir H。因此你访问第26个元素,再在它指向的链表(该链表包含所有以z打
# 头的用户名)中查找Zakhir H。

# 请问,相比于数组和链表,这种混合数据结构的查找和插入速度更慢还是更快?你不
# 必给出大O运行时间,只需指出这种新数据结构的查找和插入速度更快还是更慢。

def findSmallest(arr):
    smallest = arr[0]
    smallest_index = 0
    for i in range(1, len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smallest_index = i
    return smallest_index

def selectionSort(arr): #对数组进行排序
    newArr = []
    for i in range(len(arr)): #找出数组中最小的元素,
        smallest = findSmallest(arr) #并将其加入到新数组中
        newArr.append(arr.pop(smallest))
    return newArr

print(selectionSort([5, 3, 6, 2, 10]))

#  计算机内存犹如一大堆抽屉。
#  需要存储多个元素时,可使用数组或链表。
#  数组的元素都在一起。
#  链表的元素是分开的,其中每个元素都存储了下一个元素的地址。
#  数组的读取速度很快。
#  链表的插入和删除速度很快。
#  在同一个数组中,所有元素的类型都必须相同(都为int、double等)


def smallestEle(arr):
    small_ele = arr[0]
    small_index = 0
    for i in range(len(arr)):
        if arr[i] <= small_ele:
            small_ele = arr[i]
            small_index = i
        return small_index

def selectionsort(arr):
    new_arr = []
    for i in range(len(arr)):
        small_index = smallestEle(arr)
        new_arr.append(arr.pop(small_index))
    return new_arr

print(selectionSort([1, 34, 4, 53, 2, 999, 233, 479]))